method m_apply_row_by_row(
  _0p: Ref,
  _1p: Ref,
  _2p: Ref
)
  requires p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform(_0p)
  requires p_Adt_ClampTransform(_1p)
  requires p_Adt_Vector(_2p)
  requires s_Bool_val((((s_Bool_cons((s_Int_i32_val((s_Adt_Vector_read_0(p_Adt_Vector_snap(_2p))))) >= (((0))))))))
  requires s_Bool_val((let _0_1s_0 == (p_Adt_ClampTransform_snap(_1p)) in
(
(let _0_4s_1 == (s_Adt_Bounds_read_1(s_Adt_ClampTransform_read_0(_0_1s_0))) in
(let _0_5s_1 == (s_Adt_Bounds_read_0(s_Adt_ClampTransform_read_0(_0_1s_0))) in
s_Bool_cons((s_Int_i32_val(_0_4s_1)) < (s_Int_i32_val(_0_5s_1))))))))
  ensures p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform(_0p)
  ensures ((let _0_1s_0 == (old(p_Adt_ClampTransform_snap(_1p))) in
(let _0_2s_0 == (old(p_Adt_Vector_snap(_2p))) in
(let _0_3s_0 == (p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_snap(_0p)) in
(let _0_5s_1 == (s_Adt_Vector_read_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(_0_3s_0))) in
((((_0_5s_1) == (s_Adt_Vector_read_0(_0_2s_0))))))))))


  ensures ((let _0_1s_0 == (old(p_Adt_ClampTransform_snap(_1p))) in
(
(
(
(
(let _0_6s_1 == (Tuple_3_cons((old(p_Adt_Vector_snap(_2p))) , (p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_snap(_0p)) , _0_1s_0)) in
(forall qvar_0_0: s_Int_i32 :: ((
(let _1_2s_0 == (qvar_0_0) in
(let _1_6s_1 == (_1_2s_0) in
(let _1_5s_1 == (((((0))) <= (s_Int_i32_val(_1_6s_1)))) in // replace _1_6s_1 with qvar_0_0 here
(let _1_phi_0 == (((!_1_5s_1)? (false) : ((((s_Int_i32_val(_1_2s_0)) < (s_Int_i32_val(s_Adt_Vector_read_0(Tuple_3_elem_0(_0_6s_1))))))))) in
(
(
(_1_phi_0) 
? (let _1_12s_1 == (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(Tuple_3_elem_1(_0_6s_1))) in
  (
  (let _1_11s_1 == (f_get(_1_12s_1, _1_2s_0)) in
  (let _1_15s_1 == (Tuple_3_elem_2(_0_6s_1)) in
  (let _1_17s_1 == (Tuple_3_elem_0(_0_6s_1)) in
  (
  (let _1_16s_1 == (f_get(_1_17s_1, _1_2s_0)) in
  (let _1_14s_1 == (f_do_transform(_1_15s_1, _1_16s_1)) in
  ((_1_11s_1) == (_1_14s_1))))))))))
: (true)))))))))))))))))
 // Body removed to minimize example







method m_client(
  _0p: Ref,
  _1p: Ref
)
  requires p_Tuple0(_0p)
  requires p_Adt_Vector(_1p)
  requires ((s_Int_i32_val((s_Adt_Vector_read_0((p_Adt_Vector_snap(_1p)))))) >= (s_Int_i32_val(s_Int_i32_cons(10))))
  ensures p_Tuple0(_0p)
{
  var _2p: Ref
  inhale p_Adt_ClampTransform(_2p)
  var _3p: Ref
  inhale p_Adt_Bounds(_3p)
  
  
  var _6p: Ref
  inhale p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform(_6p)
  
 


  unfold p_Adt_Bounds(_3p)
  assume (p_Int_i32_snap(p_Adt_Bounds_field_0(_3p))) == s_Int_i32_cons(200)
  assume (p_Int_i32_snap(p_Adt_Bounds_field_1(_3p))) == s_Int_i32_cons(100)
  fold p_Adt_Bounds(_3p)

  assume ((s_Adt_ClampTransform_read_0( (p_Adt_ClampTransform_snap(_2p))))) == (p_Adt_Bounds_snap(_3p))


  m_apply_row_by_row(_6p, _2p, _1p)
  unfold p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform(_6p)

  assert s_Bool_val((let _0_1s_0 == (p_Adt_Vector_snap(p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_field_0(_6p))) in
(
(let _0_4s_1 == (_0_1s_0) in
s_Bool_cons(forall qvar_0_0: s_Int_i32 :: s_Bool_val((
(let _1_phi_0 == ((0 > (s_Int_i32_val(qvar_0_0)))  ? (false)
  : ((((s_Int_i32_val(qvar_0_0)) < (s_Int_i32_val((s_Adt_Vector_read_0(_0_1s_0)))))))) in
((((((_1_phi_0)))) ? (((f_between(f_get(_0_1s_0, qvar_0_0), s_Int_i32_cons(100), s_Int_i32_cons(200))))): s_Bool_cons(true)))

))))))))

}


// -----------------------------
// functions
// -----------------------------
function f_get(
  _1p: s_Adt_Vector,
  _2p: s_Int_i32
): s_Int_i32
  requires ((((((s_Int_i32_val(_2p)) >= (((0))))))))
  requires (((((((s_Int_i32_val(_2p)) < (s_Int_i32_val(s_Adt_Vector_read_0(_1p)))))))))
  requires ((((((s_Int_i32_val((s_Adt_Vector_read_0(_1p)))) >= (((0))))))))

function f_between(
  _1p: s_Int_i32,
  _2p: s_Int_i32,
  _3p: s_Int_i32
): s_Bool
{
((s_Bool_cons((s_Int_i32_val(_1p) <= s_Int_i32_val(_3p)) && (s_Int_i32_val(_1p) >= s_Int_i32_val(_2p)))))
}

function f_min(
  _1p: s_Int_i32,
  _2p: s_Int_i32
): s_Int_i32
{
((s_Int_i32_val(_1p)) >= (s_Int_i32_val(_2p)) ? _2p : _1p)
}

function f_max(
  _1p: s_Int_i32,
  _2p: s_Int_i32
): s_Int_i32
{
((s_Int_i32_val(_1p)) <= (s_Int_i32_val(_2p)) ? _2p : _1p)

}

function f_do_transform(
  _1p: s_Adt_ClampTransform,
  _2p: s_Int_i32
): s_Int_i32
  requires s_Bool_val((let _0_1s_0 == (_1p) in
(let _0_2s_0 == (_2p) in
(let _0_4s_1 == (s_Adt_Bounds_read_1(s_Adt_ClampTransform_read_0(_0_1s_0))) in
(let _0_5s_1 == (s_Adt_Bounds_read_0(s_Adt_ClampTransform_read_0(_0_1s_0))) in
s_Bool_cons((s_Int_i32_val(_0_4s_1)) < (s_Int_i32_val(_0_5s_1))))))))


{
  (let _0_1s_0 == (_1p) in
(let _0_2s_0 == (_2p) in
(let _0_3s_1 == (s_Adt_Bounds_read_1(s_Adt_ClampTransform_read_0(_0_1s_0))) in
(let _0_5s_1 == (s_Adt_Bounds_read_0(s_Adt_ClampTransform_read_0(_0_1s_0))) in
(let _0_6s_1 == (_0_2s_0) in
(let _0_4s_1 == (f_min(_0_5s_1, _0_6s_1)) in
f_max(_0_3s_1, _0_4s_1)))))))
}


// -----------------------------
// types
// -----------------------------
field f_s_Int_i32: s_Int_i32
domain s_Int_i32 {
  axiom ax_inverse_s_Int_i32_val_s_Int_i32_cons {
    forall val: Int :: {s_Int_i32_cons(val)} (s_Int_i32_val(s_Int_i32_cons(val))) == (val)
  }
  axiom ax_inverse_s_Int_i32_cons_s_Int_i32_val {
    forall val: s_Int_i32 :: {s_Int_i32_val(val)} (s_Int_i32_cons(s_Int_i32_val(val))) == (val)
  }
  function s_Int_i32_cons(Int): s_Int_i32
  function s_Int_i32_val(s_Int_i32): Int
}



function p_Int_i32_snap(
  self: Ref
): s_Int_i32
  requires p_Int_i32(self)
{
  unfolding p_Int_i32(self) in (self.f_s_Int_i32)
}

predicate p_Int_i32(self_p: Ref) {
  acc(self_p.f_s_Int_i32)
}

method assign_p_Int_i32(
  _p: Ref,
  _s_new: s_Int_i32
)
  ensures p_Int_i32(_p)
  ensures (p_Int_i32_snap(_p)) == (_s_new)

method reassign_p_Int_i32(
  _p: Ref,
  _s_new: s_Int_i32
)
  requires p_Int_i32(_p)
  ensures p_Int_i32(_p)
  ensures (p_Int_i32_snap(_p)) == (_s_new)

domain s_Adt_Vector {
  axiom ax_s_Adt_Vector_write_0_read_0 {
    forall self: s_Adt_Vector, val: s_Int_i32 :: {s_Adt_Vector_read_0(s_Adt_Vector_write_0(self, val))} (s_Adt_Vector_read_0(s_Adt_Vector_write_0(self, val))) == (val)
  }
  axiom ax_s_Adt_Vector_cons_read_0 {
    forall f0: s_Int_i32 :: {s_Adt_Vector_cons(f0)} (s_Adt_Vector_read_0(s_Adt_Vector_cons(f0))) == (f0)
  }
  axiom ax_s_Adt_Vector_cons {
    forall self: s_Adt_Vector :: {s_Adt_Vector_cons(s_Adt_Vector_read_0(self))} (s_Adt_Vector_cons(s_Adt_Vector_read_0(self))) == (self)
  }
  function s_Adt_Vector_cons(s_Int_i32): s_Adt_Vector
  function s_Adt_Vector_read_0(s_Adt_Vector): s_Int_i32
  function s_Adt_Vector_write_0(s_Adt_Vector, s_Int_i32): s_Adt_Vector
}

function p_Adt_Vector_field_0(
  self: Ref
): Ref
function s_Adt_Vector_unreachable(
): s_Adt_Vector
  requires false

function p_Adt_Vector_snap(
  self_p: Ref
): s_Adt_Vector
  requires p_Adt_Vector(self_p)
{
  unfolding p_Adt_Vector(self_p) in (s_Adt_Vector_cons(p_Int_i32_snap(p_Adt_Vector_field_0(self_p))))
}

predicate p_Adt_Vector(self_p: Ref) {
  p_Int_i32(p_Adt_Vector_field_0(self_p))
}


method reassign_p_Adt_Vector(
  _p: Ref,
  _s_new: s_Adt_Vector
)
  requires p_Adt_Vector(_p)
  ensures p_Adt_Vector(_p)
  ensures (p_Adt_Vector_snap(_p)) == (_s_new)

domain s_Adt_Bounds {
  axiom ax_s_Adt_Bounds_write_0_read_0 {
    forall self: s_Adt_Bounds, val: s_Int_i32 :: {s_Adt_Bounds_read_0(s_Adt_Bounds_write_0(self, val))} (s_Adt_Bounds_read_0(s_Adt_Bounds_write_0(self, val))) == (val)
  }
  axiom ax_s_Adt_Bounds_write_0_read_1 {
    forall self: s_Adt_Bounds, val: s_Int_i32 :: {s_Adt_Bounds_read_1(s_Adt_Bounds_write_0(self, val))} (s_Adt_Bounds_read_1(s_Adt_Bounds_write_0(self, val))) == (s_Adt_Bounds_read_1(self))
  }
  axiom ax_s_Adt_Bounds_write_1_read_0 {
    forall self: s_Adt_Bounds, val: s_Int_i32 :: {s_Adt_Bounds_read_0(s_Adt_Bounds_write_1(self, val))} (s_Adt_Bounds_read_0(s_Adt_Bounds_write_1(self, val))) == (s_Adt_Bounds_read_0(self))
  }
  axiom ax_s_Adt_Bounds_write_1_read_1 {
    forall self: s_Adt_Bounds, val: s_Int_i32 :: {s_Adt_Bounds_read_1(s_Adt_Bounds_write_1(self, val))} (s_Adt_Bounds_read_1(s_Adt_Bounds_write_1(self, val))) == (val)
  }
  axiom ax_s_Adt_Bounds_cons_read_0 {
    forall f0: s_Int_i32, f1: s_Int_i32 :: {s_Adt_Bounds_cons(f0, f1)} (s_Adt_Bounds_read_0(s_Adt_Bounds_cons(f0, f1))) == (f0)
  }
  axiom ax_s_Adt_Bounds_cons_read_1 {
    forall f0: s_Int_i32, f1: s_Int_i32 :: {s_Adt_Bounds_cons(f0, f1)} (s_Adt_Bounds_read_1(s_Adt_Bounds_cons(f0, f1))) == (f1)
  }
  axiom ax_s_Adt_Bounds_cons {
    forall self: s_Adt_Bounds :: {s_Adt_Bounds_cons(s_Adt_Bounds_read_0(self), s_Adt_Bounds_read_1(self))} (s_Adt_Bounds_cons(s_Adt_Bounds_read_0(self), s_Adt_Bounds_read_1(self))) == (self)
  }
  function s_Adt_Bounds_cons(s_Int_i32, s_Int_i32): s_Adt_Bounds
  function s_Adt_Bounds_read_0(s_Adt_Bounds): s_Int_i32
  function s_Adt_Bounds_write_0(s_Adt_Bounds, s_Int_i32): s_Adt_Bounds
  function s_Adt_Bounds_read_1(s_Adt_Bounds): s_Int_i32
  function s_Adt_Bounds_write_1(s_Adt_Bounds, s_Int_i32): s_Adt_Bounds
}

function p_Adt_Bounds_field_0(
  self: Ref
): Ref
function p_Adt_Bounds_field_1(
  self: Ref
): Ref
function s_Adt_Bounds_unreachable(
): s_Adt_Bounds
  requires false

function p_Adt_Bounds_snap(
  self_p: Ref
): s_Adt_Bounds
  requires p_Adt_Bounds(self_p)
{
  unfolding p_Adt_Bounds(self_p) in (s_Adt_Bounds_cons(p_Int_i32_snap(p_Adt_Bounds_field_0(self_p)), p_Int_i32_snap(p_Adt_Bounds_field_1(self_p))))
}

predicate p_Adt_Bounds(self_p: Ref) {
  (p_Int_i32(p_Adt_Bounds_field_0(self_p))) && (p_Int_i32(p_Adt_Bounds_field_1(self_p)))
}

method assign_p_Adt_Bounds(
  _p: Ref,
  _s_new: s_Adt_Bounds
)
  ensures p_Adt_Bounds(_p)
  ensures (p_Adt_Bounds_snap(_p)) == (_s_new)

method reassign_p_Adt_Bounds(
  _p: Ref,
  _s_new: s_Adt_Bounds
)
  requires p_Adt_Bounds(_p)
  ensures p_Adt_Bounds(_p)
  ensures (p_Adt_Bounds_snap(_p)) == (_s_new)

domain s_Adt_ClampTransform {
  axiom ax_s_Adt_ClampTransform_write_0_read_0 {
    forall self: s_Adt_ClampTransform, val: s_Adt_Bounds :: {s_Adt_ClampTransform_read_0(s_Adt_ClampTransform_write_0(self, val))} (s_Adt_ClampTransform_read_0(s_Adt_ClampTransform_write_0(self, val))) == (val)
  }
  axiom ax_s_Adt_ClampTransform_cons_read_0 {
    forall f0: s_Adt_Bounds :: {s_Adt_ClampTransform_cons(f0)} (s_Adt_ClampTransform_read_0(s_Adt_ClampTransform_cons(f0))) == (f0)
  }
  axiom ax_s_Adt_ClampTransform_cons {
    forall self: s_Adt_ClampTransform :: {s_Adt_ClampTransform_cons(s_Adt_ClampTransform_read_0(self))} (s_Adt_ClampTransform_cons(s_Adt_ClampTransform_read_0(self))) == (self)
  }
  function s_Adt_ClampTransform_cons(s_Adt_Bounds): s_Adt_ClampTransform
  function s_Adt_ClampTransform_read_0(s_Adt_ClampTransform): s_Adt_Bounds
  function s_Adt_ClampTransform_write_0(s_Adt_ClampTransform, s_Adt_Bounds): s_Adt_ClampTransform
}

function p_Adt_ClampTransform_field_0(
  self: Ref
): Ref
function s_Adt_ClampTransform_unreachable(
): s_Adt_ClampTransform
  requires false

function p_Adt_ClampTransform_snap(
  self_p: Ref
): s_Adt_ClampTransform
  requires p_Adt_ClampTransform(self_p)
{
  unfolding p_Adt_ClampTransform(self_p) in (s_Adt_ClampTransform_cons(p_Adt_Bounds_snap(p_Adt_ClampTransform_field_0(self_p))))
}

predicate p_Adt_ClampTransform(self_p: Ref) {
  p_Adt_Bounds(p_Adt_ClampTransform_field_0(self_p))
}

method assign_p_Adt_ClampTransform(
  _p: Ref,
  _s_new: s_Adt_ClampTransform
)
  ensures p_Adt_ClampTransform(_p)
  ensures (p_Adt_ClampTransform_snap(_p)) == (_s_new)

method reassign_p_Adt_ClampTransform(
  _p: Ref,
  _s_new: s_Adt_ClampTransform
)
  requires p_Adt_ClampTransform(_p)
  ensures p_Adt_ClampTransform(_p)
  ensures (p_Adt_ClampTransform_snap(_p)) == (_s_new)

domain s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform {
  axiom ax_s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_0_read_0 {
    forall self: s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform, val: s_Adt_Vector :: {s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_0(self, val))} (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_0(self, val))) == (val)
  }
  axiom ax_s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_0_read_1 {
    forall self: s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform, val: s_Adt_Vector :: {s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_0(self, val))} (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_0(self, val))) == (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(self))
  }
  axiom ax_s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_1_read_0 {
    forall self: s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform, val: s_Adt_ClampTransform :: {s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_1(self, val))} (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_1(self, val))) == (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(self))
  }
  axiom ax_s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_1_read_1 {
    forall self: s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform, val: s_Adt_ClampTransform :: {s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_1(self, val))} (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_1(self, val))) == (val)
  }
  axiom ax_s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons_read_0 {
    forall f0: s_Adt_Vector, f1: s_Adt_ClampTransform :: {s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(f0, f1)} (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(f0, f1))) == (f0)
  }
  axiom ax_s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons_read_1 {
    forall f0: s_Adt_Vector, f1: s_Adt_ClampTransform :: {s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(f0, f1)} (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(f0, f1))) == (f1)
  }
  axiom ax_s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons {
    forall self: s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform :: {s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(self), s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(self))} (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(self), s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(self))) == (self)
  }
  function s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(s_Adt_Vector, s_Adt_ClampTransform): s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform
  function s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform): s_Adt_Vector
  function s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_0(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform, s_Adt_Vector): s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform
  function s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_read_1(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform): s_Adt_ClampTransform
  function s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_write_1(s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform, s_Adt_ClampTransform): s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform
}

function p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_field_0(
  self: Ref
): Ref
function p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_field_1(
  self: Ref
): Ref
function s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_unreachable(
): s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform
  requires false

function p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_snap(
  self_p: Ref
): s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform
  requires p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform(self_p)
{
  unfolding p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform(self_p) in (s_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_cons(p_Adt_Vector_snap(p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_field_0(self_p)), p_Adt_ClampTransform_snap(p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_field_1(self_p))))
}

predicate p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform(self_p: Ref) {
  (p_Adt_Vector(p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_field_0(self_p))) && (p_Adt_ClampTransform(p_Tuple2_s_Adt_Vector_s_Adt_ClampTransform_field_1(self_p)))
}



field f_Tuple0: s_Tuple0
domain s_Tuple0 {
  function s_Tuple0_cons(): s_Tuple0
}

function s_Tuple0_unreachable(
): s_Tuple0
  requires false

function p_Tuple0_snap(
  self: Ref
): s_Tuple0
  requires p_Tuple0(self)

predicate p_Tuple0(self_p: Ref)

method assign_p_Tuple0(
  _p: Ref,
  _s_new: s_Tuple0
)
  ensures p_Tuple0(_p)
  ensures (p_Tuple0_snap(_p)) == (_s_new)

method reassign_p_Tuple0(
  _p: Ref,
  _s_new: s_Tuple0
)
  requires p_Tuple0(_p)
  ensures p_Tuple0(_p)
  ensures (p_Tuple0_snap(_p)) == (_s_new)

field f_Bool: s_Bool
domain s_Bool {
  axiom ax_inverse_s_Bool_val_s_Bool_cons {
    forall val: Bool :: {s_Bool_cons(val)} (s_Bool_val(s_Bool_cons(val))) == (val)
  }
  axiom ax_inverse_s_Bool_cons_s_Bool_val {
    forall val: s_Bool :: {s_Bool_val(val)} (s_Bool_cons(s_Bool_val(val))) == (val)
  }
  function s_Bool_cons(Bool): s_Bool
  function s_Bool_val(s_Bool): Bool
}

function s_Bool_unreachable(
): s_Bool
  requires false

function p_Bool_snap(
  self: Ref
): s_Bool
  requires p_Bool(self)
{
  unfolding p_Bool(self) in (self.f_Bool)
}

predicate p_Bool(self_p: Ref) {
  acc(self_p.f_Bool)
}

method assign_p_Bool(
  _p: Ref,
  _s_new: s_Bool
)
  ensures p_Bool(_p)
  ensures (p_Bool_snap(_p)) == (_s_new)

method reassign_p_Bool(
  _p: Ref,
  _s_new: s_Bool
)
  requires p_Bool(_p)
  ensures p_Bool(_p)
  ensures (p_Bool_snap(_p)) == (_s_new)




// -----------------------------
// utility types
// -----------------------------
domain Tuple_3[T0, T1, T2] {
  axiom ax_Tuple_3_elem {
    forall elem0: T0, elem1: T1, elem2: T2 :: {Tuple_3_cons(elem0, elem1, elem2)} (((Tuple_3_elem_0(Tuple_3_cons(elem0, elem1, elem2))) == (elem0)) && ((Tuple_3_elem_1(Tuple_3_cons(elem0, elem1, elem2))) == (elem1))) && ((Tuple_3_elem_2(Tuple_3_cons(elem0, elem1, elem2))) == (elem2))
  }
  function Tuple_3_elem_0(Tuple_3[T0, T1, T2]): T0
  function Tuple_3_elem_1(Tuple_3[T0, T1, T2]): T1
  function Tuple_3_elem_2(Tuple_3[T0, T1, T2]): T2
  function Tuple_3_cons(T0, T1, T2): Tuple_3[T0, T1, T2]
}

domain Tuple_1[T0] {
  axiom ax_Tuple_1_elem {
    forall elem0: T0 :: {Tuple_1_cons(elem0)} (Tuple_1_elem_0(Tuple_1_cons(elem0))) == (elem0)
  }
  function Tuple_1_elem_0(Tuple_1[T0]): T0
  function Tuple_1_cons(T0): Tuple_1[T0]
}

domain Tuple_4[T0, T1, T2, T3] {
  axiom ax_Tuple_4_elem {
    forall elem0: T0, elem1: T1, elem2: T2, elem3: T3 :: {Tuple_4_cons(elem0, elem1, elem2, elem3)} ((((Tuple_4_elem_0(Tuple_4_cons(elem0, elem1, elem2, elem3))) == (elem0)) && ((Tuple_4_elem_1(Tuple_4_cons(elem0, elem1, elem2, elem3))) == (elem1))) && ((Tuple_4_elem_2(Tuple_4_cons(elem0, elem1, elem2, elem3))) == (elem2))) && ((Tuple_4_elem_3(Tuple_4_cons(elem0, elem1, elem2, elem3))) == (elem3))
  }
  function Tuple_4_elem_0(Tuple_4[T0, T1, T2, T3]): T0
  function Tuple_4_elem_1(Tuple_4[T0, T1, T2, T3]): T1
  function Tuple_4_elem_2(Tuple_4[T0, T1, T2, T3]): T2
  function Tuple_4_elem_3(Tuple_4[T0, T1, T2, T3]): T3
  function Tuple_4_cons(T0, T1, T2, T3): Tuple_4[T0, T1, T2, T3]
}

