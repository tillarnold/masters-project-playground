    domain s_Result {
        function s_Result_cons_0(s_Int_i32): s_Result
        function s_Result_cons_1(): s_Result
        function s_Result_discriminant(s_Result): Int
        function s_Result_read_variant0_field0(s_Result): s_Int_i32
        function s_Result_write_variant0_field0(s_Result, s_Int_i32): s_Result
        

        axiom discriminant_bounds_lower {
          forall self: s_Result :: s_Result_discriminant(self) >= 0
        } 

         axiom discriminant_bounds_upper {
          forall self: s_Result :: s_Result_discriminant(self) <= 1 // number of variants
        } 

        axiom s_Result_write_read_variant_0_field_0 {
          forall self: s_Result, val: s_Int_i32 :: {s_Result_read_variant0_field0(s_Result_write_variant0_field0(self, val))}
          ( (s_Result_discriminant(self) == 0) ==>  s_Result_read_variant0_field0(s_Result_write_variant0_field0(self, val)) == (val))
       }
    }



function p_Result_discriminant(
  self: Ref
): Int
  ensures result >= 0
  ensures result <= 1


function s_Result_unreachable(
): s_Result
  requires false

function p_Result_variant_0_field_0(
  self: Ref
): Ref
  //requires p_Result_discriminant(self) == 0


function p_Result_snap(
  self_p: Ref
): s_Result
  requires p_Result(self_p)
{
  unfolding p_Result(self_p) in //(s_Adt_Vector_cons(p_Int_i32_snap(p_Adt_Vector_field_0(self_p)), p_Int_i32_snap(p_Adt_Vector_field_1(self_p))))
  let discriminant == (p_Result_discriminant(self_p)) in
    discriminant == 0 ? s_Result_cons_0(p_Int_i32_snap(p_Result_variant_0_field_0(self_p))) :
    discriminant == 1 ? s_Result_cons_1() : s_Result_unreachable()

}


predicate p_Result_some(self_p: Ref) {
   p_Result_discriminant(self_p) == 0 ==> p_Int_i32(p_Result_variant_0_field_0(self_p))
}

predicate p_Result(self_p: Ref) {
   p_Result_discriminant(self_p) == 1 || p_Result_some(self_p)
}

field f_s_Int_i32: s_Int_i32
domain s_Int_i32 {
  axiom ax_inverse_s_Int_i32_val_s_Int_i32_cons {
    forall val: Int :: {s_Int_i32_cons(val)} (s_Int_i32_val(s_Int_i32_cons(val))) == (val)
  }
  axiom ax_inverse_s_Int_i32_cons_s_Int_i32_val {
    forall val: s_Int_i32 :: {s_Int_i32_val(val)} (s_Int_i32_cons(s_Int_i32_val(val))) == (val)
  }
  function s_Int_i32_cons(Int): s_Int_i32
  function s_Int_i32_val(s_Int_i32): Int
}

function s_Int_i32_unreachable(
): s_Int_i32
  requires false

function p_Int_i32_snap(
  self: Ref
): s_Int_i32
  requires p_Int_i32(self)
{
  unfolding p_Int_i32(self) in (self.f_s_Int_i32)
}

predicate p_Int_i32(self_p: Ref) {
  acc(self_p.f_s_Int_i32)
}
