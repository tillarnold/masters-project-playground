// -----------------------------
// methods
// -----------------------------


method m_apply_id_rec_s_CALLER_(
  _0p: Ref,
  _1p: Ref
)
  requires p_Int_i32(_1p)
  ensures p_Int_i32(_0p)
  ensures s_Bool_read_0(s_Bool_cons(forall qvar_0_0: s_Int_i32 :: s_Bool_read_0(s_Bool_cons(s_Ref_Not_cons(f_id(qvar_0_0)) == (s_Ref_Not_cons(s_Ref_Not_read_0(s_Ref_Not_cons(f_id(qvar_0_0)))))))))
{
  assign_p_Int_i32(_0p, s_Int_i32_cons(1))
  exhale p_Int_i32(_1p)
}


// -----------------------------
// functions
// -----------------------------
function f_id(_1p: s_Int_i32): s_Int_i32 {
_1p
}

// -----------------------------
// MIR builtins
// -----------------------------
// -----------------------------
// generics
// -----------------------------
// -----------------------------
// snapshots
// -----------------------------
domain s_Int_i32 {
  axiom ax_s_Int_i32_cons_read_0 {
    forall f0: Int :: {s_Int_i32_cons(f0)} (s_Int_i32_read_0(s_Int_i32_cons(f0))) == (f0)
  }
  axiom ax_s_Int_i32_cons {
    forall self: s_Int_i32 :: {s_Int_i32_read_0(self)} (s_Int_i32_cons(s_Int_i32_read_0(self))) == (self)
  }
  axiom ax_s_Int_i32_write_0_read_0 {
    forall self: s_Int_i32, val: Int :: {s_Int_i32_read_0(s_Int_i32_write_0(self, val))} (s_Int_i32_read_0(s_Int_i32_write_0(self, val))) == (val)
  }
  axiom s_Int_i32_bounds {
    forall self: s_Int_i32 :: {s_Int_i32_read_0(self)} ((-(2147483648)) <= (s_Int_i32_read_0(self))) && ((s_Int_i32_read_0(self)) <= (2147483647))
  }
  function s_Int_i32_cons(Int): s_Int_i32
  function s_Int_i32_read_0(s_Int_i32): Int
  function s_Int_i32_write_0(s_Int_i32, Int): s_Int_i32
}

domain s_Bool {
  axiom ax_s_Bool_cons_read_0 {
    forall f0: Bool :: {s_Bool_cons(f0)} (s_Bool_read_0(s_Bool_cons(f0))) == (f0)
  }
  axiom ax_s_Bool_cons {
    forall self: s_Bool :: {s_Bool_cons(s_Bool_read_0(self))} (s_Bool_cons(s_Bool_read_0(self))) == (self)
  }
  axiom ax_s_Bool_write_0_read_0 {
    forall self: s_Bool, val: Bool :: {s_Bool_read_0(s_Bool_write_0(self, val))} (s_Bool_read_0(s_Bool_write_0(self, val))) == (val)
  }
  function s_Bool_cons(Bool): s_Bool
  function s_Bool_read_0(s_Bool): Bool
  function s_Bool_write_0(s_Bool, Bool): s_Bool
}

domain s_0_Tuple {
  function s_0_Tuple_cons(): s_0_Tuple
}

domain s_Ref_Not[T] {
  axiom ax_s_Ref_Not_cons_read_0 {
    forall f0: T :: {s_Ref_Not_cons(f0)} (s_Ref_Not_read_0(s_Ref_Not_cons(f0))) == (f0)
  }
  axiom ax_s_Ref_Not_cons {
    forall self: s_Ref_Not[T] :: {s_Ref_Not_cons(s_Ref_Not_read_0(self))} (s_Ref_Not_cons(s_Ref_Not_read_0(self))) == (self)
  }
  axiom ax_s_Ref_Not_write_0_read_0 {
    forall self: s_Ref_Not[T], val: T :: {s_Ref_Not_read_0(s_Ref_Not_write_0(self, val))} (s_Ref_Not_read_0(s_Ref_Not_write_0(self, val))) == (val)
  }
  function s_Ref_Not_cons(T): s_Ref_Not[T]
  function s_Ref_Not_read_0(s_Ref_Not[T]): T
  function s_Ref_Not_write_0(s_Ref_Not[T], T): s_Ref_Not[T]
}

// -----------------------------
// types
// -----------------------------
field f_Int_i32: s_Int_i32
function p_Int_i32_unreachable(
): s_Int_i32
  requires false
  ensures false

function p_Int_i32_snap(
  self: Ref
): s_Int_i32
  requires acc(p_Int_i32(self), wildcard)
{
  unfolding acc(p_Int_i32(self), wildcard) in (self.f_Int_i32)
}

predicate p_Int_i32(self: Ref) {
  acc(self.f_Int_i32)
}

method assign_p_Int_i32(
  self: Ref,
  self_new: s_Int_i32
)
  ensures p_Int_i32(self)
  ensures (p_Int_i32_snap(self)) == (self_new)

field f_Bool: s_Bool
function p_Bool_unreachable(
): s_Bool
  requires false
  ensures false

function p_Bool_snap(
  self: Ref
): s_Bool
  requires acc(p_Bool(self), wildcard)
{
  unfolding acc(p_Bool(self), wildcard) in (self.f_Bool)
}

predicate p_Bool(self: Ref) {
  acc(self.f_Bool)
}

method assign_p_Bool(
  self: Ref,
  self_new: s_Bool
)
  ensures p_Bool(self)
  ensures (p_Bool_snap(self)) == (self_new)

function p_0_Tuple_unreachable(
): s_0_Tuple
  requires false
  ensures false

function p_0_Tuple_snap(
  self: Ref
): s_0_Tuple
  requires acc(p_0_Tuple(self), wildcard)
{
  unfolding acc(p_0_Tuple(self), wildcard) in (s_0_Tuple_cons())
}

predicate p_0_Tuple(self: Ref) {
  true
}

method assign_p_0_Tuple(
  self: Ref,
  self_new: s_0_Tuple
)
  ensures p_0_Tuple(self)
  ensures (p_0_Tuple_snap(self)) == (self_new)

